--- FILE: grok-integration/src/extension.ts ---

Replace the existing `redactSecrets` function (approximately lines 140-155, based on the provided code structure) with this improved version to enhance secret detection patterns, adding support for more common credential formats like AWS keys, database URLs, and credit card numbers while maintaining targeted replacements to avoid Unicode issues:

```typescript
function redactSecrets(text: string): string {
  return text
    // API keys (various formats)
    .replace(/(api[_-]?key\s*[:=]\s*[\"']?)([^\"'\s\n]{10,})([\"']?)/gi, '$1REDACTED$3')
    .replace(/(apikey\s*[:=]\s*[\"']?)([^\"'\s\n]{10,})([\"']?)/gi, '$1REDACTED$3')
    // Tokens
    .replace(/(token\s*[:=]\s*[\"']?)([^\"'\s\n]{20,})([\"']?)/gi, '$1REDACTED$3')
    .replace(/(bearer\s+)([a-zA-Z0-9._-]{20,})/gi, '$1REDACTED')
    // Passwords
    .replace(/(password\s*[:=]\s*[\"']?)([^\"'\s\n]{3,})([\"']?)/gi, '$1REDACTED$3')
    .replace(/(passwd\s*[:=]\s*[\"']?)([^\"'\s\n]{3,})([\"']?)/gi, '$1REDACTED$3')
    // JWT tokens (more specific pattern)
    .replace(/\b(eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*)\b/g, 'JWT_TOKEN_REDACTED')
    // Email addresses (PII)
    .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, 'EMAIL_REDACTED')
    // Phone numbers (basic patterns)
    .replace(/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g, 'PHONE_REDACTED')
    // SSH private keys
    .replace(/(-----BEGIN [A-Z ]+PRIVATE KEY-----)([\s\S]*?)(-----END [A-Z ]+PRIVATE KEY-----)/gi, '$1\nREDACTED\n$3')
    // AWS keys
    .replace(/(AWS_ACCESS_KEY_ID\s*[:=]\s*[\"']?)([A-Z0-9]{20})([\"']?)/gi, '$1REDACTED$3')
    .replace(/(AWS_SECRET_ACCESS_KEY\s*[:=]\s*[\"']?)([A-Za-z0-9/+=]{40})([\"']?)/gi, '$1REDACTED$3')
    // Database URLs
    .replace(/(postgres(?:ql)?|mysql|mongodb)\:\/\/([^:]+):([^@]+)@/gi, '$1://REDACTED:REDACTED@')
    // Credit card numbers (basic Luhn-like pattern)
    .replace(/\b(?:\d[ -]*?){13,19}\b/g, 'CARD_REDACTED');
}
```

--- FILE: grok-integration/src/extension.ts ---

Insert this code after the existing `generateCacheKey` function (approximately line 120) to add encryption for cache entries, enhancing security by protecting cached responses from potential memory dumps or unauthorized access:

```typescript
// Secure cache encryption (requires Node.js crypto)
function encryptCacheEntry(entry: CacheEntry): string {
  const crypto = require('crypto');
  const key = crypto.randomBytes(32); // In production, use a secure, persisted key
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
  let encrypted = cipher.update(JSON.stringify(entry));
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return iv.toString('hex') + ':' + encrypted.toString('hex');
}

function decryptCacheEntry(encrypted: string): CacheEntry {
  const crypto = require('crypto');
  const [ivHex, encryptedHex] = encrypted.split(':');
  const iv = Buffer.from(ivHex, 'hex');
  const encryptedText = Buffer.from(encryptedHex, 'hex');
  const key = crypto.randomBytes(32); // Match the encryption key
  const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
  let decrypted = decipher.update(encryptedText);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return JSON.parse(decrypted.toString());
}

// Update setToCache to encrypt
function setToCache(key: string, response: string, tokenCount: number): void {
  if (!cache || !isCacheEnabled() || typeof key !== 'string' || typeof response !== 'string') {
    return;
  }
  
  if (key.length === 0 || response.length === 0) {
    return;
  }
  
  const maxResponseSize = 1000000; // 1MB
  if (response.length > maxResponseSize) {
    console.warn(`Response too large for caching: ${response.length} bytes`);
    return;
  }
  
  try {
    const cacheEntry: CacheEntry = {
      response,
      timestamp: Date.now(),
      tokenCount
    };
    const encryptedEntry = encryptCacheEntry(cacheEntry);
    cache.set(key, { ...cacheEntry, response: encryptedEntry }); // Store encrypted
  } catch (error) {
    console.error('Error setting cache entry:', error);
  }
}

// Update getFromCache to decrypt
function getFromCache(key: string): CacheEntry | undefined {
  if (!cache || !isCacheEnabled() || typeof key !== 'string' || key.length === 0) {
    return undefined;
  }
  
  try {
    const cached = cache.get(key);
    if (cached) {
      if (!cached.timestamp || !cached.response || typeof cached.timestamp !== 'number') {
        console.warn(`Invalid cache entry found for key: ${key}`);
        cache.delete(key);
        return undefined;
      }
      
      const decryptedResponse = decryptCacheEntry(cached.response);
      const isExpired = Date.now() - cached.timestamp > CACHE_TTL_MS;
      
      if (isExpired) {
        cache.delete(key);
        return undefined;
      }
      return { ...cached, response: decryptedResponse.response };
    }
    return undefined;
  } catch (error) {
    console.error('Error retrieving from cache:', error);
    return undefined;
  }
}
```

--- FILE: grok-integration/src/extension.ts ---

Replace the path resolution in `showGrokPanel` (within the applyChanges function, approximately lines 600-620) with this to add stricter path validation and prevent any potential traversal attacks:

```typescript
// Security: Validate path - must be relative, no '..', no absolute paths, and within workspace
let filePath = change.file.trim();
if (filePath.startsWith('/')) {
  filePath = filePath.slice(1);
}
if (path.isAbsolute(filePath) || filePath.includes('..') || filePath.includes('\\') || !/^[a-zA-Z0-9_./-]+$/.test(filePath)) {
  vscode.window.showErrorMessage(`Invalid file path: ${change.file}. Must be relative within workspace without '..', backslashes, or invalid characters.`);
  continue;
}
const resolvedPath = path.normalize(path.join(workspaceRoot, filePath));
if (!resolvedPath.startsWith(workspaceRoot) || resolvedPath.includes('..')) {
  vscode.window.showErrorMessage(`Path traversal detected: ${change.file}. Skipping.`);
  continue;
}
const fileUri = vscode.Uri.file(resolvedPath);
```